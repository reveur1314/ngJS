<!DOCTYPE html>
<!-- saved from url=(0044)http://www.angularjs.net.cn/tutorial/22.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>AngularJS 单元测试</title>
<link rel="icon" href="http://www.angularjs.net.cn/Application/Home/View/Public/img/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="./20AngularJS 单元测试_files/bootstrap.min.css">
<link href="./20AngularJS 单元测试_files/prettify.css" rel="stylesheet">
<script src="./20AngularJS 单元测试_files/hm.js.下载"></script><script src="./20AngularJS 单元测试_files/prettify.js.下载"></script>


<link rel="stylesheet" href="./20AngularJS 单元测试_files/style.css">

</head>
<body onload="prettyPrint()">
<div id="top">
	<div class="container">
	<div class="logo"><a href="http://www.angularjs.net.cn/">AngularJs中文网</a></div>
	<ul>
		<li><a href="http://www.angularjs.net.cn/">首页</a></li>
		<li><a href="http://www.angularjs.net.cn/tutorial/">AngularJS 教程</a></li>
		
		<li><a href="http://www.angularjs.net.cn/phonecat/">AngularJS PhoneCat</a></li>
		<li><a href="http://www.angularjs.net.cn/download/">AngularJS 下载</a></li>
		<li><a href="http://www.angularjs.net.cn/api/">AngularJS api</a></li>
		<li style="display:none;"><a href="http://www.angularjs.net.cn/angular-seed">AngularJS Seed</a></li>
	<li><a href="https://promotion.aliyun.com/ntms/act/qwbk.html?userCode=iuvvbh9n" onclick="_hmt.push([&#39;_trackEvent&#39;, &#39;nav&#39;, &#39;click&#39;, &#39;Ecs&#39;])" target="_blank">Ecs服务器</a></li>
	

	
	</ul>
	</div>
</div>


<div class="container">
	<div class="row">
		<div class="col-md-3">
<ul>
	<li><a href="http://www.angularjs.net.cn/tutorial/1.html">简介（Introduction）</a></li><li><a href="http://www.angularjs.net.cn/tutorial/16.html">引导程序（Bootstrap）</a></li><li><a href="http://www.angularjs.net.cn/tutorial/18.html">概念概述(Conceptual Overview)</a></li><li><a href="http://www.angularjs.net.cn/tutorial/15.html">Html编译（HTML Compiler）</a></li><li><a href="http://www.angularjs.net.cn/tutorial/10.html">数据绑定（Data Binding）</a></li><li><a href="http://www.angularjs.net.cn/tutorial/2.html">控制器(Controllers)</a></li><li><a href="http://www.angularjs.net.cn/tutorial/19.html">服务（Services）</a></li><li><a href="http://www.angularjs.net.cn/tutorial/12.html">作用域(Scope)</a></li><li><a href="http://www.angularjs.net.cn/tutorial/17.html">依赖注入(Dependency Injection)</a></li><li><a href="http://www.angularjs.net.cn/tutorial/13.html">模板（Templates）</a></li><li><a href="http://www.angularjs.net.cn/tutorial/11.html">使用css(Working With CSS)</a></li><li><a href="http://www.angularjs.net.cn/tutorial/8.html">过滤器（Filters）</a></li><li><a href="http://www.angularjs.net.cn/tutorial/4.html">表单(Forms)</a></li><li><a href="http://www.angularjs.net.cn/tutorial/5.html">指令(Directives)</a></li><li><a href="http://www.angularjs.net.cn/tutorial/20.html">Components</a></li><li><a href="http://www.angularjs.net.cn/tutorial/21.html">Component Router</a></li><li><a href="http://www.angularjs.net.cn/tutorial/7.html">动画(Animations)</a></li><li><a href="http://www.angularjs.net.cn/tutorial/6.html">模块(Modules)</a></li><li><a href="http://www.angularjs.net.cn/tutorial/3.html">表达式(Expressions)</a></li><li><a href="http://www.angularjs.net.cn/tutorial/9.html">供应者（Providers）</a></li><li><a href="http://www.angularjs.net.cn/tutorial/14.html">$location</a></li><li><a href="http://www.angularjs.net.cn/tutorial/22.html">单元测试</a></li><li><a href="http://www.angularjs.net.cn/tutorial/23.html">端对端测试</a></li></ul>
<div id="ad" class="">
<script async="" src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 160x600 -->
<ins class="adsbygoogle" style="display:inline-block;width:160px;height:600px" data-ad-client="ca-pub-6117966252207595" data-ad-slot="1088261149"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>
</div>
		<div class="col-md-9">
			<div class="page-header"><h1>AngularJS 单元测试</h1></div>

<div style="margin-bottom:10px;">
<script async="" src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 728x90 --><ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-6117966252207595" data-ad-slot="2639707541"></ins>
<script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
<script async="" src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 728x90 --><ins class="adsbygoogle" style="display:inline-block;width:728px;height:90px" data-ad-client="ca-pub-6117966252207595" data-ad-slot="2639707541"></ins>
<script>(adsbygoogle = window.adsbygoogle || []).push({});</script>
</div>
			
			
<p>JavaScript是一个动态类型的语言，具有强大的表达能力，但同时，你几乎没法从编译器获得任何帮助。
    因此，我们深切体会到：任何JavaScript程序都需要伴随着一组强大的测试。
    我们在angular中引入了很多特性来让你更轻松的测试应用程序。
    所以，想不写测试？不，没有任何借口！</p>
<h2 id="一切的关键是：不要把不同的任务揉成一团">一切的关键是：不要把不同的任务揉成一团</h2>
<p>单元测试，顾名思义就是用于测试代码中不可分割的单元。单元测试试图回答下列问题：“我所认为的逻辑正确吗？”或者“我的sort函数是否按照正确的顺序排序了这个列表？”</p>
<p>为了回答上述问题，最重要的事情就是：我们要能把这个单元的代码隔离到一个独立的test模块中。
    这是因为我们测试sort函数的时候，绝不会希望也被迫创建相关的部分 —— 比如DOM元素，或者先发起一个XHR调用来获取完数据才能测试sort函数。</p>
<p>虽然这看起来无所谓，但在一个典型的项目中，想要调用一个独立函数确实是非常困难的。
    原因在于，开发人员经常会把不同的任务揉成一团，导致一部分代码中往往会做很多很多事：发起XHR请求，对返回的数据进行排序，然后更新到DOM。</p>
<p>在Angular中，我们尝试进行简化，来确保你总能“做正确的事”，所以，我们提供了依赖注入（DI），来让你自由使用XHR（这样你就能mock它了）；
    我们创建了抽象层，让你可以排序你的模型(Model)，而不用去管DOM。
    最终的结果就是：很容易写出这样一个对一些数据进行排序的sort函数，你的测试程序可以创建一组数据、调用sort函数，然后验证这些数据是否被按照正确的顺序排列了。
    这个测试不用等XHR返回结果，不用想方设法创建正确类型的测试用DOM，也不用验证DOM节点是否根据排好的顺序发生了变化。</p>
<h3 id="一切的关键是：不要把不同的任务揉成一团_angular确实做了很多，但你也不能偷懒">Angular确实做了很多，但你也不能偷懒</h3>
<p>写Angular的核心思想之一就是“可测试性”，但是它仍然需要你按照正确的方式使用它。
    你当然希望轻而易举的把事情做对，但Angular不是魔术。如果你不遵循下列指导原则，你仍然很可能得到一个不可测试的程序。</p>
<h3 id="一切的关键是：不要把不同的任务揉成一团_依赖注入">依赖注入(DI)</h3>
<p>你可以有很多种方式获得所依赖的对象。比如：</p>
<ol>
    <li>通过<code><span class="kwd">new</span></code>运算符创建一个。</li>
    <li>在一个众所周知的地方找一个现成的，比如全局性的单例(singleton)对象。</li>
    <li>从一个注册表(registry)（比如服务注册表）中找一个现成的。（但是你如何找到一个注册表的引用呢？通常要从一个众所周知的地方寻找。参见#2。）</li>
    <li>等别人把它“递”到你手里。</li>
</ol>
<p>在这四种方案中，只有最后一种是可测试的。让我们分析一下这是为什么：</p>
<h4 id="一切的关键是：不要把不同的任务揉成一团_依赖注入_使用运算符">使用<code><span class="kwd">new</span></code>运算符</h4>
<p>本质上，使用<code><span class="kwd">new</span></code>运算符没有错，问题出在从构造函数中调用<code><span class="kwd">new</span></code>运算符的时候。
    这种情况下，调用者被永久性的和它要<code><span class="kwd">new</span></code>的这个类型绑定在一起。比如，如果为了从服务器获得数据而对XHR进行实例化会导致什么后果？</p>
<pre class="prettyprint linenums"><ol class="linenums"><li class="L0"><span class="kwd">function</span><span class="pln"> </span><span class="typ">MyClass</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span></li><li class="L1"><span class="pln">  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">doWork </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span></li><li class="L2"><span class="pln">    </span><span class="kwd">var</span><span class="pln"> xhr </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> XHR</span><span class="pun">();</span></li><li class="L3"><span class="pln">    xhr</span><span class="pun">.</span><span class="pln">open</span><span class="pun">(</span><span class="pln">method</span><span class="pun">,</span><span class="pln"> url</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">);</span></li><li class="L4"><span class="pln">    xhr</span><span class="pun">.</span><span class="pln">onreadystatechange </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{...}</span></li><li class="L5"><span class="pln">    xhr</span><span class="pun">.</span><span class="pln">send</span><span class="pun">();</span></li><li class="L6"><span class="pln">  </span><span class="pun">}</span></li><li class="L7"><span class="pun">}</span></li></ol></pre>
<p>在测试时，问题表现在：当我们想要实例化一个<code><span class="typ">MockXHR</span></code> —— 我们需要它来返回模拟数据，并且模拟网络异常。
    如果我们调用<code><span class="kwd">new</span><span class="pln"> XHR</span><span class="pun">()</span></code>来获得实例，我们就永久性的和实际的XHR（而不是Mock的！）绑定在一起，并且没有任何办法替换它。
    固然，我们可以使用猴子补丁（译注：monkey patch —— 见下面例子），但这绝对是个坏注意，理由很多，不过本文档中不展开论述。</p>
<p>下面是一个例子，可以看出为何即使借助于猴子补丁仍然不是个好办法。
</p><pre class="prettyprint linenums"><ol class="linenums"><li class="L0"><span class="kwd">var</span><span class="pln"> oldXHR </span><span class="pun">=</span><span class="pln"> XHR</span><span class="pun">;</span></li><li class="L1"><span class="pln">XHR </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="typ">MockXHR</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{};</span></li><li class="L2"><span class="kwd">var</span><span class="pln"> myClass </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">MyClass</span><span class="pun">();</span></li><li class="L3"><span class="pln">myClass</span><span class="pun">.</span><span class="pln">doWork</span><span class="pun">();</span></li><li class="L4"><span class="com">// 确保MockXHR按照正确的参数进行了调用</span></li><li class="L5"><span class="pln">XHR </span><span class="pun">=</span><span class="pln"> oldXHR</span><span class="pun">;</span><span class="pln"> </span><span class="com">// 如果你忘了写这句，就糟了</span></li></ol></pre>
<h4 id="一切的关键是：不要把不同的任务揉成一团_依赖注入_全局查找：">全局查找：</h4>
<p>另一个方法是从一个众所周知的地方查找此服务。</p>
<pre class="prettyprint linenums"><ol class="linenums"><li class="L0"><span class="kwd">function</span><span class="pln"> </span><span class="typ">MyClass</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span></li><li class="L1"><span class="pln">  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">doWork </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span></li><li class="L2"><span class="pln">    </span><span class="kwd">global</span><span class="pun">.</span><span class="pln">xhr</span><span class="pun">({</span></li><li class="L3"><span class="pln">      method</span><span class="pun">:</span><span class="str">'...'</span><span class="pun">,</span></li><li class="L4"><span class="pln">      url</span><span class="pun">:</span><span class="str">'...'</span><span class="pun">,</span></li><li class="L5"><span class="pln">      complete</span><span class="pun">:</span><span class="kwd">function</span><span class="pun">(</span><span class="pln">response</span><span class="pun">){</span><span class="pln"> </span><span class="pun">...</span><span class="pln"> </span><span class="pun">}</span></li><li class="L6"><span class="pln">    </span><span class="pun">})</span></li><li class="L7"><span class="pln">  </span><span class="pun">}</span></li><li class="L8"><span class="pun">}</span></li></ol></pre>
<p>虽然这次没有直接创建新的依赖对象，问题和<code><span class="kwd">new</span></code>方案仍是一样的：测试方无法拦截对<code><span class="kwd">global</span><span class="pun">.</span><span class="pln">xhr</span></code>的调用 —— 除非通过猴子补丁。
    对测试来说，根本问题在于全局变量应该允许被测试方修改，以便能替换它，并且调用一个mock函数。
    关于“这种方式为什么不好”的详细论述请参见：
    <a href="http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons/">孤僻的全局状态和单例对象</a></p>
<p>上面这个类之所以难于测试，原因就在于我们不得不修改全局状态：
</p><pre class="prettyprint linenums"><ol class="linenums"><li class="L0"><span class="kwd">var</span><span class="pln"> oldXHR </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">global</span><span class="pun">.</span><span class="pln">xhr</span><span class="pun">;</span></li><li class="L1"><span class="kwd">global</span><span class="pun">.</span><span class="pln">xhr </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> mockXHR</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{};</span></li><li class="L2"><span class="kwd">var</span><span class="pln"> myClass </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">MyClass</span><span class="pun">();</span></li><li class="L3"><span class="pln">myClass</span><span class="pun">.</span><span class="pln">doWork</span><span class="pun">();</span></li><li class="L4"><span class="com">// 确保mockXHR使用正确的参数调用了</span></li><li class="L5"><span class="kwd">global</span><span class="pun">.</span><span class="pln">xhr </span><span class="pun">=</span><span class="pln"> oldXHR</span><span class="pun">;</span><span class="pln"> </span><span class="com">// 如果你忘了写这句，就糟了</span></li></ol></pre>
<h4 id="一切的关键是：不要把不同的任务揉成一团_依赖注入_服务注册表">服务注册表</h4>
<p>粗看起来似乎有一个好办法解决这个问题：创建一个注册表，它保存着所有服务，那么测试方就可以替换这些服务了。</p>
<pre class="prettyprint linenums"><ol class="linenums"><li class="L0"><span class="kwd">function</span><span class="pln"> </span><span class="typ">MyClass</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span></li><li class="L1"><span class="pln">  </span><span class="kwd">var</span><span class="pln"> serviceRegistry </span><span class="pun">=</span><span class="pln"> </span><span class="pun">????;</span></li><li class="L2"><span class="pln">  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">doWork </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span></li><li class="L3"><span class="pln">    </span><span class="kwd">var</span><span class="pln"> xhr </span><span class="pun">=</span><span class="pln"> serviceRegistry</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">'xhr'</span><span class="pun">);</span></li><li class="L4"><span class="pln">    xhr</span><span class="pun">({</span></li><li class="L5"><span class="pln">      method</span><span class="pun">:</span><span class="str">'...'</span><span class="pun">,</span></li><li class="L6"><span class="pln">      url</span><span class="pun">:</span><span class="str">'...'</span><span class="pun">,</span></li><li class="L7"><span class="pln">      complete</span><span class="pun">:</span><span class="kwd">function</span><span class="pun">(</span><span class="pln">response</span><span class="pun">){</span><span class="pln"> </span><span class="pun">...</span><span class="pln"> </span><span class="pun">}</span></li><li class="L8"><span class="pln">    </span><span class="pun">})</span></li><li class="L9"><span class="pun">}</span></li></ol></pre>
<p>问题在于，serviceRegistry从哪里来呢？如果：</p>
<ul>
    <li>是 new 出来的，那么测试方没有机会重定义这些服务以供测试。</li>
    <li>来自全局查找，那么所返回的服务也是全局的（但是重定义比较容易，因为需要重定义的只有一个全局变量）</li>
</ul>
<p>上面的这个类仍然难于测试，因为我们还是不得不修改全局状态：
</p><pre class="prettyprint linenums"><ol class="linenums"><li class="L0"><span class="kwd">var</span><span class="pln"> oldServiceLocator </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">global</span><span class="pun">.</span><span class="pln">serviceLocator</span><span class="pun">;</span></li><li class="L1"><span class="kwd">global</span><span class="pun">.</span><span class="pln">serviceLocator</span><span class="pun">.</span><span class="kwd">set</span><span class="pun">(</span><span class="str">'xhr'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> mockXHR</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{});</span></li><li class="L2"><span class="kwd">var</span><span class="pln"> myClass </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">MyClass</span><span class="pun">();</span></li><li class="L3"><span class="pln">myClass</span><span class="pun">.</span><span class="pln">doWork</span><span class="pun">();</span></li><li class="L4"><span class="com">// 确保mockXHR被使用正确的参数调用</span></li><li class="L5"><span class="kwd">global</span><span class="pun">.</span><span class="pln">serviceLocator </span><span class="pun">=</span><span class="pln"> oldServiceLocator</span><span class="pun">;</span><span class="pln"> </span><span class="com">// 如果你忘了写这句，就糟了</span></li></ol></pre>
<h4 id="一切的关键是：不要把不同的任务揉成一团_依赖注入_传入依赖对象">传入依赖对象</h4>
<p>最后，可以被动接收所依赖的对象。</p>
<pre class="prettyprint linenums"><ol class="linenums"><li class="L0"><span class="kwd">function</span><span class="pln"> </span><span class="typ">MyClass</span><span class="pun">(</span><span class="pln">xhr</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></li><li class="L1"><span class="pln">  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">doWork </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span></li><li class="L2"><span class="pln">    xhr</span><span class="pun">({</span></li><li class="L3"><span class="pln">      method</span><span class="pun">:</span><span class="str">'...'</span><span class="pun">,</span></li><li class="L4"><span class="pln">      url</span><span class="pun">:</span><span class="str">'...'</span><span class="pun">,</span></li><li class="L5"><span class="pln">      complete</span><span class="pun">:</span><span class="kwd">function</span><span class="pun">(</span><span class="pln">response</span><span class="pun">){</span><span class="pln"> </span><span class="pun">...</span><span class="pln"> </span><span class="pun">}</span></li><li class="L6"><span class="pln">    </span><span class="pun">})</span></li><li class="L7"><span class="pun">}</span></li></ol></pre>
<p>这是首选方案！因为这段代码让我们不用对<code><span class="pln">xhr</span></code>从哪里来作出任何假设，而只要知道谁负责创建这个类并且传给我们就够了。
    因为类的创建者和类的使用者一般不是同一段代码，这里把创建类的职责从应用逻辑里分离出去。这就是依赖注入的简易原理。</p>
<p>上面这个类是可测试的，在测试代码中我们可以这样写：
</p><pre class="prettyprint linenums"><ol class="linenums"><li class="L0"><span class="kwd">function</span><span class="pln"> xhrMock</span><span class="pun">(</span><span class="pln">args</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{...}</span></li><li class="L1"><span class="kwd">var</span><span class="pln"> myClass </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">MyClass</span><span class="pun">(</span><span class="pln">xhrMock</span><span class="pun">);</span></li><li class="L2"><span class="pln">myClass</span><span class="pun">.</span><span class="pln">doWork</span><span class="pun">();</span></li><li class="L3"><span class="com">// 确保xhrMock使用正确的参数调用</span></li></ol></pre>
<p>注意，这个测试中我们不用写任何全局变量。</p>
<p>Angular内建了<a href="http://www.angularjs.net.cn/tutorial/guide/di">依赖注入</a>机制，让你可以很容易的“做正确的事”，但是如果你希望在可测试性方面更进一步，你还需要了解更多。 </p>
<h3 id="一切的关键是：不要把不同的任务揉成一团_控制器">控制器(Controller)</h3>
<p>让应用程序与众不同的地方在于它的“逻辑”，而“逻辑”正是我们想要测试的对象。
    如果你的应用逻辑中包含了DOM操作，它就很难被测试了。参见下面的例子：</p>
<pre class="prettyprint linenums"><ol class="linenums"><li class="L0"><span class="kwd">function</span><span class="pln"> </span><span class="typ">PasswordCtrl</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span></li><li class="L1"><span class="pln">  </span><span class="com">// 获得DOM元素的引用</span></li><li class="L2"><span class="pln">  </span><span class="kwd">var</span><span class="pln"> msg </span><span class="pun">=</span><span class="pln"> $</span><span class="pun">(</span><span class="str">'.ex1 span'</span><span class="pun">);</span></li><li class="L3"><span class="pln">  </span><span class="kwd">var</span><span class="pln"> input </span><span class="pun">=</span><span class="pln"> $</span><span class="pun">(</span><span class="str">'.ex1 input'</span><span class="pun">);</span></li><li class="L4"><span class="pln">  </span><span class="kwd">var</span><span class="pln"> strength</span><span class="pun">;</span></li><li class="L5"><span class="pln">&nbsp;</span></li><li class="L6"><span class="pln">  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">grade </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span></li><li class="L7"><span class="pln">    msg</span><span class="pun">.</span><span class="pln">removeClass</span><span class="pun">(</span><span class="pln">strength</span><span class="pun">);</span></li><li class="L8"><span class="pln">    </span><span class="kwd">var</span><span class="pln"> pwd </span><span class="pun">=</span><span class="pln"> input</span><span class="pun">.</span><span class="pln">val</span><span class="pun">();</span></li><li class="L9"><span class="pln">    password</span><span class="pun">.</span><span class="pln">text</span><span class="pun">(</span><span class="pln">pwd</span><span class="pun">);</span></li><li class="L0"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">pwd</span><span class="pun">.</span><span class="pln">length </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">8</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></li><li class="L1"><span class="pln">      strength </span><span class="pun">=</span><span class="pln"> </span><span class="str">'strong'</span><span class="pun">;</span></li><li class="L2"><span class="pln">    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">pwd</span><span class="pun">.</span><span class="pln">length </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">3</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></li><li class="L3"><span class="pln">      strength </span><span class="pun">=</span><span class="pln"> </span><span class="str">'medium'</span><span class="pun">;</span></li><li class="L4"><span class="pln">    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span></li><li class="L5"><span class="pln">      strength </span><span class="pun">=</span><span class="pln"> </span><span class="str">'weak'</span><span class="pun">;</span></li><li class="L6"><span class="pln">    </span><span class="pun">}</span></li><li class="L7"><span class="pln">    msg</span></li><li class="L8"><span class="pln">     </span><span class="pun">.</span><span class="pln">addClass</span><span class="pun">(</span><span class="pln">strength</span><span class="pun">)</span></li><li class="L9"><span class="pln">     </span><span class="pun">.</span><span class="pln">text</span><span class="pun">(</span><span class="pln">strength</span><span class="pun">);</span></li><li class="L0"><span class="pln">  </span><span class="pun">}</span></li><li class="L1"><span class="pun">}</span></li></ol></pre>
<p>上述代码在可测试性方面的问题在于，它需要你的测试代码在执行被测代码时提供正确类型的DOM。测试代码看起来将是这样的：</p>
<pre class="prettyprint linenums"><ol class="linenums"><li class="L0"><span class="kwd">var</span><span class="pln"> input </span><span class="pun">=</span><span class="pln"> $</span><span class="pun">(</span><span class="str">'&lt;input type="text"/&gt;'</span><span class="pun">);</span></li><li class="L1"><span class="kwd">var</span><span class="pln"> span </span><span class="pun">=</span><span class="pln"> $</span><span class="pun">(</span><span class="str">'&lt;span&gt;'</span><span class="pun">);</span></li><li class="L2"><span class="pln">$</span><span class="pun">(</span><span class="str">'body'</span><span class="pun">).</span><span class="pln">html</span><span class="pun">(</span><span class="str">'&lt;div class="ex1"&gt;'</span><span class="pun">)</span></li><li class="L3"><span class="pln">  </span><span class="pun">.</span><span class="pln">find</span><span class="pun">(</span><span class="str">'div'</span><span class="pun">)</span></li><li class="L4"><span class="pln">    </span><span class="pun">.</span><span class="pln">append</span><span class="pun">(</span><span class="pln">input</span><span class="pun">)</span></li><li class="L5"><span class="pln">    </span><span class="pun">.</span><span class="pln">append</span><span class="pun">(</span><span class="pln">span</span><span class="pun">);</span></li><li class="L6"><span class="kwd">var</span><span class="pln"> pc </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">PasswordCtrl</span><span class="pun">();</span></li><li class="L7"><span class="pln">input</span><span class="pun">.</span><span class="pln">val</span><span class="pun">(</span><span class="str">'abc'</span><span class="pun">);</span></li><li class="L8"><span class="pln">pc</span><span class="pun">.</span><span class="pln">grade</span><span class="pun">();</span></li><li class="L9"><span class="pln">expect</span><span class="pun">(</span><span class="pln">span</span><span class="pun">.</span><span class="pln">text</span><span class="pun">()).</span><span class="pln">toEqual</span><span class="pun">(</span><span class="str">'weak'</span><span class="pun">);</span></li><li class="L0"><span class="pln">$</span><span class="pun">(</span><span class="str">'body'</span><span class="pun">).</span><span class="pln">html</span><span class="pun">(</span><span class="str">''</span><span class="pun">);</span></li></ol></pre>
<p>在angular的设计中，控制器和DOM操作被严密的隔离开，其效果就是可以更轻易的提供可测试性，如下所示：</p>
<pre class="prettyprint linenums"><ol class="linenums"><li class="L0"><span class="kwd">function</span><span class="pln"> </span><span class="typ">PasswordCtrl</span><span class="pun">(</span><span class="pln">$scope</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></li><li class="L1"><span class="pln">  $scope</span><span class="pun">.</span><span class="pln">password </span><span class="pun">=</span><span class="pln"> </span><span class="str">''</span><span class="pun">;</span></li><li class="L2"><span class="pln">  $scope</span><span class="pun">.</span><span class="pln">grade </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span></li><li class="L3"><span class="pln">    </span><span class="kwd">var</span><span class="pln"> size </span><span class="pun">=</span><span class="pln"> $scope</span><span class="pun">.</span><span class="pln">password</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span></li><li class="L4"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">size </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">8</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></li><li class="L5"><span class="pln">      $scope</span><span class="pun">.</span><span class="pln">strength </span><span class="pun">=</span><span class="pln"> </span><span class="str">'strong'</span><span class="pun">;</span></li><li class="L6"><span class="pln">    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">size </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">3</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span></li><li class="L7"><span class="pln">      $scope</span><span class="pun">.</span><span class="pln">strength </span><span class="pun">=</span><span class="pln"> </span><span class="str">'medium'</span><span class="pun">;</span></li><li class="L8"><span class="pln">    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span></li><li class="L9"><span class="pln">      $scope</span><span class="pun">.</span><span class="pln">strength </span><span class="pun">=</span><span class="pln"> </span><span class="str">'weak'</span><span class="pun">;</span></li><li class="L0"><span class="pln">    </span><span class="pun">}</span></li><li class="L1"><span class="pln">  </span><span class="pun">};</span></li><li class="L2"><span class="pun">}</span></li></ol></pre>
<p>测试代码也立即变得整洁了：</p>
<pre class="prettyprint linenums"><ol class="linenums"><li class="L0"><span class="kwd">var</span><span class="pln"> $scope </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{};</span></li><li class="L1"><span class="kwd">var</span><span class="pln"> pc </span><span class="pun">=</span><span class="pln"> $controller</span><span class="pun">(</span><span class="str">'PasswordCtrl'</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> $scope</span><span class="pun">:</span><span class="pln"> $scope </span><span class="pun">});</span></li><li class="L2"><span class="pln">$scope</span><span class="pun">.</span><span class="pln">password </span><span class="pun">=</span><span class="pln"> </span><span class="str">'abc'</span><span class="pun">;</span></li><li class="L3"><span class="pln">$scope</span><span class="pun">.</span><span class="pln">grade</span><span class="pun">();</span></li><li class="L4"><span class="pln">expect</span><span class="pun">(</span><span class="pln">$scope</span><span class="pun">.</span><span class="pln">strength</span><span class="pun">).</span><span class="pln">toEqual</span><span class="pun">(</span><span class="str">'weak'</span><span class="pun">);</span></li></ol></pre>
<p>注意，测试代码不仅仅是变短了，也能更简明的体现出发生了什么。我们看到这段代码“描述了一个故事”，而不只是一组看起来互不相关的“点”。</p>
<h3 id="一切的关键是：不要把不同的任务揉成一团_过滤器">过滤器(Filter)</h3>
<p><a href="http://www.angularjs.net.cn/tutorial/api/ng.$filterProvider"><code><span class="pun">过滤器</span></code></a>是一个函数，用来把数据转换成用户可读的格式。
    它们的重要性在于把数据格式化方面的职责从应用逻辑中移除了，从而简化了应用逻辑。</p>
<pre class="prettyprint linenums"><ol class="linenums"><li class="L0"><span class="pln">myModule</span><span class="pun">.</span><span class="pln">filter</span><span class="pun">(</span><span class="str">'length'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span></li><li class="L1"><span class="pln">  </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">text</span><span class="pun">){</span></li><li class="L2"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="str">''</span><span class="pun">+(</span><span class="pln">text</span><span class="pun">||</span><span class="str">''</span><span class="pun">)).</span><span class="pln">length</span><span class="pun">;</span></li><li class="L3"><span class="pln">  </span><span class="pun">}</span></li><li class="L4"><span class="pun">});</span></li><li class="L5"><span class="pln">&nbsp;</span></li><li class="L6"><span class="kwd">var</span><span class="pln"> length </span><span class="pun">=</span><span class="pln"> $filter</span><span class="pun">(</span><span class="str">'length'</span><span class="pun">);</span></li><li class="L7"><span class="pln">expect</span><span class="pun">(</span><span class="pln">length</span><span class="pun">(</span><span class="kwd">null</span><span class="pun">)).</span><span class="pln">toEqual</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span></li><li class="L8"><span class="pln">expect</span><span class="pun">(</span><span class="pln">length</span><span class="pun">(</span><span class="str">'abc'</span><span class="pun">)).</span><span class="pln">toEqual</span><span class="pun">(</span><span class="lit">3</span><span class="pun">);</span></li></ol></pre>
<h3 id="一切的关键是：不要把不同的任务揉成一团_指令">指令(Directive)</h3>
<p>Angular中的指令，用于通过自定义HTML标记(Tag)、属性(Attribute)、类(Class)或注释(Comment)的形式封装复杂的功能。
    对于指令来说，单元测试是非常重要的，因为你创建的指令有可能被用于你的整个应用程序中，甚至被用在很多不同的环境中。</p>
<h4 id="一切的关键是：不要把不同的任务揉成一团_指令_简单html型元素指令">简单HTML型元素指令</h4>
<p>我们先定义一个不依赖其他模块的angular应用。</p>
<pre class="prettyprint linenums"><ol class="linenums"><li class="L0"><span class="kwd">var</span><span class="pln"> app </span><span class="pun">=</span><span class="pln"> angular</span><span class="pun">.</span><span class="kwd">module</span><span class="pun">(</span><span class="str">'myApp'</span><span class="pun">,</span><span class="pln"> </span><span class="pun">[]);</span></li></ol></pre>
<p>然后在我们的应用中添加一个指令。</p>
<pre class="prettyprint linenums ng-binding"><ol class="linenums"><li class="L0"><span class="pln">app</span><span class="pun">.</span><span class="pln">directive</span><span class="pun">(</span><span class="str">'aGreatEye'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span></li><li class="L1"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">{</span></li><li class="L2"><span class="pln">        restrict</span><span class="pun">:</span><span class="pln"> </span><span class="str">'E'</span><span class="pun">,</span></li><li class="L3"><span class="pln">        replace</span><span class="pun">:</span><span class="pln">  </span><span class="kwd">true</span><span class="pun">,</span></li><li class="L4"><span class="pln">        </span><span class="kwd">template</span><span class="pun">:</span><span class="pln"> </span><span class="str">'&lt;h1&gt;lidless, wreathed in flame, 2 times&lt;/h1&gt;'</span></li><li class="L5"><span class="pln">    </span><span class="pun">};</span></li><li class="L6"><span class="pun">});</span></li></ol></pre>
<p>这个这个指令作为标记(tag)时的用法是<code><span class="tag">&lt;a-great-eye&gt;&lt;/a-great-eye&gt;</span></code>。
    这个标记会被模板<code><span class="tag">&lt;h1&gt;</span><span class="pln">lidless, wreathed in flame, {{1 + 1}} times</span><span class="tag">&lt;/h1&gt;</span></code>代替。
    另外，这里的<code><span class="pun">{{</span><span class="lit">1</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">}}</span></code>表达式在渲染内容时也将被计算。
    接下来，我们将写一个jasmine（一种单元测试框架）单元测试，来验证这个功能。</p>
<pre class="prettyprint linenums ng-binding"><ol class="linenums"><li class="L0"><span class="pln">describe</span><span class="pun">(</span><span class="str">'单元测试集'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span></li><li class="L1"><span class="pln">    </span><span class="kwd">var</span><span class="pln"> $compile</span><span class="pun">;</span></li><li class="L2"><span class="pln">    </span><span class="kwd">var</span><span class="pln"> $rootScope</span><span class="pun">;</span></li><li class="L3"><span class="pln">&nbsp;</span></li><li class="L4"><span class="pln">    </span><span class="com">// 加载myApp模块，它包含着指令</span></li><li class="L5"><span class="pln">    beforeEach</span><span class="pun">(</span><span class="kwd">module</span><span class="pun">(</span><span class="str">'myApp'</span><span class="pun">));</span></li><li class="L6"><span class="pln">&nbsp;</span></li><li class="L7"><span class="pln">    </span><span class="com">// 保存$rootScope和$compile的引用，以便它们能被这里的所有测试使用</span></li><li class="L8"><span class="pln">    beforeEach</span><span class="pun">(</span><span class="pln">inject</span><span class="pun">(</span><span class="kwd">function</span><span class="pun">(</span><span class="pln">_$compile_</span><span class="pun">,</span><span class="pln"> _$rootScope_</span><span class="pun">){</span></li><li class="L9"><span class="pln">      </span><span class="com">// 注射器匹配的时候会去掉参数名两端的下划线再匹配</span></li><li class="L0"><span class="pln">      $compile </span><span class="pun">=</span><span class="pln"> _$compile_</span><span class="pun">;</span></li><li class="L1"><span class="pln">      $rootScope </span><span class="pun">=</span><span class="pln"> _$rootScope_</span><span class="pun">;</span></li><li class="L2"><span class="pln">    </span><span class="pun">}));</span></li><li class="L3"><span class="pln">    </span></li><li class="L4"><span class="pln">    it</span><span class="pun">(</span><span class="str">'用适当的内容替换元素'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span></li><li class="L5"><span class="pln">        </span><span class="com">// 编译一块包含指令的HTML</span></li><li class="L6"><span class="pln">        </span><span class="kwd">var</span><span class="pln"> element </span><span class="pun">=</span><span class="pln"> $compile</span><span class="pun">(</span><span class="str">"&lt;a-great-eye&gt;&lt;/a-great-eye&gt;"</span><span class="pun">)(</span><span class="pln">$rootScope</span><span class="pun">);</span></li><li class="L7"><span class="pln">	</span><span class="com">// 触发所有的监听(watch)，以便在作用域中计算表达式2</span></li><li class="L8"><span class="pln">        $rootScope</span><span class="pun">.</span><span class="pln">$digest</span><span class="pun">();</span></li><li class="L9"><span class="pln">	</span><span class="com">// 检查编译后的元素中包含了模板中的内容</span></li><li class="L0"><span class="pln">        expect</span><span class="pun">(</span><span class="pln">element</span><span class="pun">.</span><span class="pln">html</span><span class="pun">()).</span><span class="pln">toContain</span><span class="pun">(</span><span class="str">"lidless, wreathed in flame, 2 times"</span><span class="pun">);</span></li><li class="L1"><span class="pln">    </span><span class="pun">});</span></li><li class="L2"><span class="pun">});</span></li></ol></pre>
<p>我们在每个jasmine测试中注入了$compile服务和$rootScope对象。
    $compile服务用于渲染aGreatEye指令。
    渲染这个指令后我们确保指令已经把内容替换成了 "lidless, wreathed in flame, 2 times" </p>
<h3 id="一切的关键是：不要把不同的任务揉成一团_范例工程">范例工程</h3>
<p>范例工程参见 <a href="https://github.com/angular/angular-seed">Angular种子工程</a>。</p>
	<div class="ad1">	
<script async="" src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 336 x 280 -->
<ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-6117966252207595" data-ad-slot="9942648348"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>
</div>	
	
		</div>
	</div>
</div>
<footer>
	<p>Copyright © 2014 - 2018 <a href="http://www.angularjs.net.cn/">AngularJS中文网</a>, <a href="http://www.miitbeian.gov.cn/" target="_blank">粤ICP备15074038号-4</a>, All Rights Reserved.

</p>
</footer>
<script type="text/javascript">
    /*图+推广*/
    /*建议投放在200*300以上的图片*/
    var cpro_id = "u1948815";
</script>
<script type="text/javascript" src="./20AngularJS 单元测试_files/i.js.下载"></script>


<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?12ec03a62d55d8fb4b144b14ccedecec";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


<script src="./20AngularJS 单元测试_files/jquery.js.下载"></script>
<script src="./20AngularJS 单元测试_files/common.js.下载"></script>
<script src="./20AngularJS 单元测试_files/bootstrap.min.js.下载"></script>

</body></html>